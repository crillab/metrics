# Reading a Campaign into *Metrics*

To extract pieces of data from the campaign of experiments you ran and feed it
into *Metrics*, you need to use the *Scalpel* module of *Metrics*.
*Scalpel* stands for *"extraCt dAta of exPeriments from softwarE Logs"*
(*sCAlPEL*).

A campaign is basically read using the following:

```python
from metrics.scalpel import read_campaign
my_campaign = read_campaign("path/to/campaign/file")
```

Currently, two types of files can be given as input to *Scalpel*:

+ a JSON file containing a serialized form of the campaign (when
  you have already loaded your campaign in *Metrics*, and saved
  it for later use), or
+ a YAML file describing how to extract data from the campaign
  you ran.

In the first case, there is almost nothing to do, as the JSON file generated
by *Metrics* already contains all the data needed by *Scalpel*.
In the second case, the following sections give more details on how to write
a configuration file that describes your campaign.

## Metadata of the Campaign

In your YAML file, you first need to give elementary informations about the
campaign, such as its name and the date on which it has been run.

```yaml
name: my-awesome-campaign
date: 2020-10-26
```

These informations are used to identify your campaign, and are particularly
interesting for the traceability of your experiments.

Your YAML file must also contain the experimental setup on which the campaign
took place, as in the following example.

```yaml
setup:
  os: Linux CentOS 7 (x86_64)
  cpu: Intel XEON X5550 (2.66 GHz, 8 MB cache)
  ram: 32GB
  timeout: 1800
  memout: 1024MB
```

Note that, for the setup description, only the timeout is required.
The other values may be displayed in the reports generated by *Metrics* for
reproducibility purposes.

## Description of the Experiment-Wares

Optionally, you may provide a description of the experiment-wares (i.e., the
software programs you ran during your campaign).
By default, these programs are automagically instantiated when encountered
during the parsing of your campaign files.

However, you may want to specify additional data w.r.t. the programs you
experimented (for instance, the version of the software, the command line
options passed to the program that was executed, etc.).
Such data may not be present in your campaign files.

In this case, you can specify them in the YAML configuration as follows:

```yaml
experiment-wares:
  - name: my-awesome-xpware
    version: 0.1.0
    command-line: ./my-awesome-xpware -o option
  - name: my-great-xpware
    commit-sha: abcd1234
    command-line: ./my-great-xpware -v value
```

When you specify informations for your experiment-wares, only their
names are required.
This name must uniquely identify the experiment-ware in the campaign.
For all other informations you specify, you may use any key you want to
identify these informations.

Also, note that you are not required to use the same keys for all
experiment-wares.
You may also omit experiment-wares for which you do not need more
informations than those mentionned in the campaign files: these
experiment-wares will simply be discovered when parsing the files.

Moreover, you may simply specify the list of the experiment-wares used
in the campaign:

```yaml
experiment-wares:
  - my-awesome-xpware
  - my-great-xpware
```

Doing so is rarely useful, as the name of the experiment-wares must necessarily
be mentionned in the campaign files, and thus will be discovered during their
parsing.
However, this may be helpful to remind you that some experiments are missing,
for instance, if you do not have run all experiment-wares yet.

## Description of the Inputs

```yaml
input-set:
  name:
  type:
  family:
  input-name:
  extensions:
    -
  path-list:
      -
```

## Description of the Campaign Files

*Scalpel* is able to parse a wide variety of files that contain the output
of the experiments you ran during your campaign.
All informations describing the source of your campaign must be given
in the `source` field of your YAML configuration file.
The first key of this field is the `path`of the file(s) containing the data
to extract.

```yaml
source:
  path:
    - path/to/first/file
    - path/to/second/file
```

This key declares the list of the files (either regular files or directories
depending on the format of your campaign) that Scalpel will parse.
Note that all files must have the same format.

All these files will be parsed sequentially, and their content will be merged
into a single campaign.
If this files represent distinct parts of your campaign (e.g., each file
contains the result of a different experiment-ware), you may be interested
in the [extraction of metadata from the name of the file](#file-name-metadata).

If you only have one file containing all the results of your campaign, you may
avoid the use of a list, and simply write the path of the file as value
for `path`:

```yaml
source:
  path: path/to/single/file
```

In the following subsections, we present what you must add to the `source`
field to configure `Scalpel` for parsing your campaign, depending on its
format.

### Parsing a CSV File

The CSV (Comma-Separated Values) format is often used to store experimental
data.
It is mainly a tabular format, which has an (optional) *header* line giving
the titles of the column.
Each of the remaining lines corresponds to the data collected during an
experiment.

Depending on the variant, columns may be separated by:

+ a comma (`,`), giving the default `csv` format,
+ a semi-colon (`;`), giving the `csv2` format, or
+ a tabulation (`\t`), giving the `table` format.

To specify that your campaign is in one of these formats, you need to add the
following to your YAML configuration file:

```yaml
source:
  path: path/to/my/file.csv
  format: csv
```

Actually, the `format` may be omitted in this example, as the extension of 
the file already tells *Scalpel* that the file is in the (classical) `csv`
format.
Similarly, if you specify as `path` the files `path/to/my/file.csv2` or
`path/to/my/file.table`, you may omit the format, as *Scalpel* will infer
that such files use the `csv2` and `table` formats, respectively.

You may also have more "exotic" CSV-like files, which do not use a standard
separator or quote character (by default, `"` is used as quote character).
If this is the case, you may describe them by adding the following keys:

```yaml
source:
  quote-char: "%"
  separator: "|"
```

In the example above, the quote character is `%` and the columns are
separated by the characted `|`.

Finally, you may have a header for your CSV file, or not.
By default, the first line is considered as a header line, and is used
to identify the values parsed in the other lines as experimental data.
If you do not have a header line, add the following key:

```yaml
source:
  has-header: false
```

In this case, values will be identified by the index of the corresponding
column, as a string (starting from `"0"`).
Note that, in this case, *Scalpel*'s naming convention cannot be followed.
As such, do not forget to specify the mapping of the columns in the text file
to fit *Scalpel*'s needs (see [below](#variable-mapping) for more details).
You must also do so as long as the name of the columns in your CSV files do not
fit *Scalpel*'s expectation.

### Parsing an "Evaluation" File

If you are interested in analyzing the results of a campaign run with
the so-called "Evaluation" platform (such as, for instance, the
[results of the XCSP'19 competition](http://www.cril.univ-artois.fr/XCSP19/),
we provide a parser to read the "results of individual jobs as text file"
provided by this platform (as the text file of the XCSP'19 competition,
available [here](http://www.cril.univ-artois.fr/XCSP19/results/export.php?idev=99)).

To do so, specify the following in your YAML configuration file:

```yaml
source:
  path: path/to/result/file.txt
  format: evaluation
```

As this platform do not use in general the same naming convention as that of
*Scalpel*, do not forget to specify the mapping of the columns in the text file
to fit *Scalpel*'s needs (see [below](#variable-mapping) for more details).

### Parsing Raw Data from a Directory Containing All Outputs

```yaml
source:
  path:
  format:
```

### Parsing Raw Data from a Complete File Hierarchy

```yaml
source:
  path:
  format:
  hierarchy-depth:
  experiment-ware:
```

### Parsing Unsupported Formats

When developing *Scalpel*, we tried to think about as many campaign formats
as possible.
However, it may happen that you need to parse a campaign that use a format
that is not recognized (yet) by *Scalpel*.
If this is the case you may write your own parser. by extending the class
`CampaignParser`.
This class must define a constructor taking as argument a `ScalpelConfiguration`
and a `CampaignParserListener`.
To give you ideas on how to write such a parser, you may have a look to the
[source of our parsers](https://github.com/crillab/metrics/tree/master/metrics/scalpel/parser).

Then, add the class of you parser to your YAML configuration file as follows:

```yaml
source:
  parser: my.completely.specified.AwesomeParser
```

*Scalpel* will dynamically instantiate your parser, and will then use it
to parse the campaign.

> **Remark**
>
> If you need to parse a campaign that uses an unsupported format, do not
> hesitate to submit an issue, with an example of what you want to parse.
> We will provide you some advices for writing your own parser.
>
> We may also add a new feature to *Scalpel* by supporting this format,
> either by writing a parser or by integrating yours if you agree to contribute
> and submit a pull request.

### Identifying Successful Experiments

## Description of the Data to Extract

```yaml
data:
  mapping:
    experiment_ware:
    cpu_time:
    input:
  file-name-meta:
    pattern:
    regex:
    experiment_ware:
    input:
  raw-data:
    - log-data:
      name:
      pattern:
      regex:
      group:
  data-files:
    -
```